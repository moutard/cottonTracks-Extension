'use strict';

/**
 * Pretreatment are launch only once to compute all that will be necessary and
 * frequently used.
 *
 * Notes : PreTreatment is used in the worker, so all data received are
 * serialized. That's why, lVisitItem is a list of Object (dictionary). And not
 * a list of Cotton.Model.VisitItem.
 */
Cotton.Algo.PreTreatment = {};

/**
 * For each oVisitItem in lVisitItems, compute parseUrl.
 * Notes : an array is a primitive type so passed by value.
 *
 * @param lVisitItems
 * @returns
 */
Cotton.Algo.PreTreatment.computeParseUrl = function(lVisitItems) {
  // Instead of computing every time you compute a distance

  for ( var i = 0; i < lVisitItems.length; i++) {
    var oUrl = new UrlParser(lVisitItems[i]['sUrl']);
    // assign oUrl.
    lVisitItems[i]['oUrl'] = oUrl;
    lVisitItems[i]['sPathname'] = oUrl.pathname;
    lVisitItems[i]['sHostname'] = oUrl.hostname;
  }
  return lVisitItems;
};

/**
 * For each oVisitItem in lVisitItems, extract words of the title.
 *
 * @param lVisitItems
 * @returns
 */
Cotton.Algo.PreTreatment.computeExtractedWords = function(lVisitItems) {
  // Instead of computing every time you compute a distance

  for ( var i = 0; i < lVisitItems.length; i++) {
    lVisitItems[i]['oExtractedDNA']['lExtractedWords'] = [].concat(
        Cotton.Algo.Tools.extractWordsFromTitle(lVisitItems[i]['sTitle']),
        Cotton.Algo.Tools.extractWordsFromUrlPathname(lVisitItems[i]['oUrl']['pathname'])
        );
  }
  return lVisitItems;
};


Cotton.Algo.PreTreatment.computeClosestGeneratedPage = function(lVisitItems) {
  // For all visitItems find the closest page generated by a search with
  // query keywords. Store this keywords on the object.

  var iSliceTime = Cotton.Config.Parameters.iSliceTime;
  // After this time a page is considered as non-linked with a query search page
  var sNonFound = "http://www.google.fr/";
  var oCurrentSearchPage = {
    'sUrl' : "http://www.google.fr/",
    'iVisitTime' : 0
  };

  for ( var i = lVisitItems.length - 1; i >= 0; i--) {
    // Inverse Loop.
    // This method is working because lVisitItems is sorted by iVisitTime.
    var oUrl = new parseUrl(lVisitItems[i]['sUrl']);
    // TODO(rmoutard) : maybe put all the oUrl.
    lVisitItems[i]['sPathname'] = oUrl.pathname;
    lVisitItems[i]['sHostname'] = oUrl.hostname;
    if (oUrl.pathname === "/search") {
      // We found a page generated by a search with query keywords
      oUrl.generateKeywords();

      lVisitItems[i]['oExtractedDNA']['sClosestGeneratedPage'] = lVisitItems[i]['sUrl'];
      lVisitItems[i]['oExtractedDNA']['lQueryWords'] = oUrl.keywords;
      oCurrentSearchPage = lVisitItems[i];
    } else {
      if (Math.abs(oCurrentSearchPage['iVisitTime']
          - lVisitItems[i]['iVisitTime']) <= iSliceTime) {

        lVisitItems[i]['oExtractedDNA']['sClosestGeneratedPage'] = oCurrentSearchPage['sUrl'];
        lVisitItems[i]['oExtractedDNA']['lQueryWords'] = oCurrentSearchPage['oExtractedDNA']['lQueryWords'];
      } else {

        lVisitItems[i]['oExtractedDNA']['sClosestGeneratedPage'] = sNonFound;
        lVisitItems[i]['oExtractedDNA']['lQueryWords'] = [];
      }
    }
  }

  return lVisitItems;
};

/**
 * Tag each visitItem is lVisitItems with the closest google search. Only if
 * there are some common words, between query keywords and title or url.
 *
 * @param lVisitItems
 * @returns
 */
Cotton.Algo.PreTreatment.computeClosestGoogleSearchPage = function(lVisitItems) {

  var iSliceTime = Cotton.Config.Parameters.iSliceTime;
  // After this time a page is considered as non-linked with a query search page

  var sNonFound = "http://www.google.fr/";

  for ( var i = 0; i < lVisitItems.length; i++) {
    var oCurrentPage = lVisitItems[i];
    var iSearchIndex = i;
    var oTempPage = lVisitItems[iSearchIndex];

    // value by default
    oCurrentPage['oExtractedDNA']['sClosestGeneratedPage'] = sNonFound;
    oCurrentPage['oExtractedDNA']['lQueryWords'] = [];

    while(oTempPage &&
        Math.abs(oCurrentPage['iVisitTime'] - oTempPage['iVisitTime']) < iSliceTime
        ){
        if (oTempPage['oUrl']['keywords'] &&
            _.intersection( oTempPage['oUrl']['keywords'],
                            oCurrentPage['oExtractedDNA']['lExtractedWords']).length > 0 ){
          // we found a page that should be the google closest query page.
          oCurrentPage['oExtractedDNA']['sClosestGeneratedPage'] = oTempPage['sUrl'];
          oCurrentPage['oExtractedDNA']['lQueryWords'] = oTempPage['oUrl']['keywords'];
          break;
        } else {
          // the temp page is not a good google search page.
          // try the newt one.
          iSearchIndex += 1;
          oTempPage = lVisitItems[iSearchIndex];
        }
    }
  }

  return lVisitItems;
};

/**
 * Apply all the pretreatment to lVisitItems.
 * Note: array is a primitive type so it's passed by value.
 * @param {Array.
 *          <Object>} lVisitItems
 * @returns {Array.<Object>}
 */
Cotton.Algo.PreTreatment.suite = function(lVisitItems) {
  // The order is important!
  lVisitItems = Cotton.Algo.PreTreatment.computeParseUrl(lVisitItems);
  lVisitItems = Cotton.Algo.PreTreatment.computeExtractedWords(lVisitItems);
  lVisitItems = Cotton.Algo.PreTreatment
      .computeClosestGoogleSearchPage(lVisitItems);

  return lVisitItems;
};
